## Refining `@Configuration`
We can define our `@Configuration` beans directly within the Application class
```java
@Configuration
public class AppGamingSpringBeans {
    @Bean
    // Beans 1...

    @Bean
    // Beans 2...

    public static void main(String[] args) {
        try (var context = new AnnotationConfigApplicationContext(AppGamingSpringBeans.class)) {
            context.getBean(GameRunner.class).run();
        }
    }
}
```
## `@Component` & `@ComponentScan`
We can auto-configure beans so we don't need to use `@Beans` methods, by instead using:
1. **`@Component`** to declare our classes as beans
    ```java
    @Component
    public class PacManGame implements IGamingConsole {
        // ...
    }
    ```
2.  **`@ComponentScan`** to our Application to enable scanning
    ```java
    @Configuration
    @ComponentScan
    public class AppGamingSpringBeans {
        // We can remove all our @Beans now, because we are using @ComponentScan
        public static void main(String[] args) {
            try (var context = new AnnotationConfigApplicationContext(AppGamingSpringBeans.class)) {
                context.getBean(GameRunner.class).run();
            }
        }
    }
    ```
> Now our beans are generated by scanning `@Component` classes instead of `@Beans` method.

## `@Component` with `@Primary`

We can use `@Primary` to specify the default implementation to wire

```java
@Component
@Primary
public class PacManGame implements IGamingConsole {
    // ...
}
```

## `@Component` with `@Qualifier`

We can use `@Qualifier` to specify witch implementation to wire.

```java
@Component
@Qualifier("mario")
public class MarioGame implements IGamingConsole {
    // ...
}
```
```java
public class GameRunner {
    private IGamingConsole game;
    public GameRunner(@Qualifier("mario") IGamingConsole game) {
        this.game = game;
    }
    // ...
}
```

## Dependency Injection Types

There is three types of dependency injection:
1. Constructor injection: Dependency is injected in the constructor.
    ```java
    @Component
    class YourBusinessClass {
        Dependency1 dependency1;
        Dependency2 dependency2;
        @Autowired
        public YourBusinessClass(Dependency1 dependency1, Dependency2 dependency2) {
            this.dependency1 = dependency1;
            this.dependency2 = dependency2;
        }
        // ...
    }
    ```
    > `@Autowired` is not require for constructor injection (unless there is multiple constructors)
2. Setter injection: Dependency is injected by calling the setter method.
    ```java
    @Component
    class YourBusinessClass {
        Dependency1 dependency1;
        Dependency2 dependency2;
        @Autowired
        public void setDependency1(Dependency1 dependency1) {
            this.dependency1 = dependency1;
        }
        @Autowired
        public void setDependency2(Dependency2 dependency2) {
            this.dependency2 = dependency2;
        }
        // ...
    }
    ```
3. Field injection: Dependency is injected using *reflection*
    ```java
    @Component
    class YourBusinessClass {
        @Autowired
        Dependency1 dependency1;
        @Autowired
        Dependency2 dependency2;
        // ...
    }
    ```
   > We must annotate with `@Autowired` for field injection

Constructor injection is the prefered way because:
- It is easier to unit test.
- The dependencies are immutable (its created once at instanciation).

## Important Terminology

1. **Component**: An instance of a class managed by Spring's IoC container, typically annotated with `@Component`.
2. **Dependency**: A required object that a class needs to function.
3. **Component Scan**: The process that Spring uses to automatically discover and register components (`@Component`, `@Service`, `@Repository`, etc.) in the application context.
4. **Dependency Injection**: A design pattern where Spring identifies the dependencies of a bean and automatically provides them.
5. **Inversion of Control (IoC)**: The principle of delegating control of object creation and dependency management to the Spring framework.
6. **Spring Beans**: Objects that are instantiated, assembled, and managed by Spring's IoC container.
7. **IoC Container**: The core of Spring's framework that manages the lifecycle of beans and resolves dependencies.
   - **2 Types**: **ApplicationContext** (complex), **BeanFactory** (simpler features - rarely used).
8. **Autowiring**: The process of automatically injecting dependencies for a Spring bean by using `@Autowired`.

## `@Component` vs `@Bean`

|                      | `@Component`                                  | `@Bean`                                                                                                             |
| -------------------- | --------------------------------------------- | ------------------------------------------------------------------------------------------------------------------- |
| **Where?**           | Can be used on any Java class                 | Typically used on methods in Spring Configuration classes                                                           |
| **Ease of use**      | Very easy. Just add an annotation.            | You write all the code.                                                                                             |
| **Autowiring**       | Yes - Field, Setter or Constructor Injection. | Yes - Method Call, or Method Parameters.                                                                            |
| **Who create beans** | Spring Framework.                             | You write bean creation code.                                                                                       |
| **Recommended For**  | Instantiating Beans for Your Own Application  | 1. Custom Business Logic</br>2. Instantiating Beans for 3rd-party libraries (where we don't have access to classes) |

